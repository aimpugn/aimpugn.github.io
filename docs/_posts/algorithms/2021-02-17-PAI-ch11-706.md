---
title: 706 해시맵 디자인
author: aimpugn
date: 2021-02-17 22:00:00+0900
use_math: true
categories: [PAI, algorithms]
---

- [해시맵 디자인](#해시맵-디자인)
  - [문제](#문제)
  - [조건](#조건)
  - [예제](#예제)
  - [해결](#해결)
    - [1st](#1st)
      - [1.1 해결해야 할 사항](#11-해결해야-할-사항)
      - [1.2 생각](#12-생각)
      - [1.3 구현](#13-구현)

# [해시맵 디자인](https://leetcode.com/problems/design-hashmap/)

## 문제

> Design a HashMap without using any built-in hash table libraries.
> To be specific, your design should include these functions:
>
> - put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.
> - get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
> - remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.

## 조건

- $0 \le keys, values \le 1,000,000$
- $0 \le \text{The number of operations}\le 10,000$
- Please do not use the built-in HashMap library.

## 예제

```python
MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);          
hashMap.put(2, 2);         
hashMap.get(1);            // returns 1
hashMap.get(3);            // returns -1 (not found)
hashMap.put(2, 1);          // update the existing value
hashMap.get(2);            // returns 1 
hashMap.remove(2);          // remove the mapping for 2
hashMap.get(2);            // returns -1 (not found)
```

## 해결

### 1st

#### 1.1 해결해야 할 사항

- 예제를 보면 기본적인 딕셔녀리와 비슷해 보인다.
- 파이썬에 내장된 해시 테이블 라이브러리 사용하지 말 것. 그렇다면 내장된 해시 테이블 라이브러리는 뭐지?
  - [hashlib](https://docs.python.org/ko/3.10/library/hashlib.html)를 쓰지 말라는 건가?
  - [파이썬에서 해시 테이블은?](https://wiki.python.org/moin/DictionaryKeys) 결국 딕셔너리

> Python's dictionary implementation reduces the average complexity of dictionary lookups to O(1) by requiring that key objects provide a "hash" function

- 파이썬에서 dictionary 조회 과정은?
  1. 키의 해시 값은 hash 함수 사용하여 계산된다
  2. 해시 값은 key, value 쌍을 갖는 `buckets` 또는 `충돌 리스트(collision lists)` 배열의 위치를 가리킨다
  3. `pair[0] == key`에 해당하는 쌍을 찾을 때까지 해시 값이 가리키는 `충돌 리스트(collision lists)`를 탐색하고, 해당 쌍의 `pair[1]`을 반환

```python
def lookup(d, key):
    h = hash(key)           # step 1
    cl = d.data[h]          # step 2: d.data는 `buckets` 또는 `충돌 리스트` 배열
    for pair in cl:         # step 3
        if key == pair[0]:  # pair는 tuple인가?
            return pair[1]
    else:
        raise KeyError, "Key %s not found." % key
```

- 그렇다면 딕셔너리를 그대로 사용하는 게 아니라, 다른 방식 사용

#### 1.2 생각

- 개별 체이닝과 오픈 어드레싱 두 가지 방식 사용 가능
- 개별 체이닝 시?
  - 연결 리스트로 구현
  - 해시는? mod 등 분산 방법 고려
- 오픈 어드레싱?
  - Python처럼 버킷 또는 충돌 리스트에 저장하여 구현
  - 해시는? 마찬가지로 고르게 분배
- 개별 체이닝으로 하고, 해시 방식을 좀 더 고려해보자
- 좋은 해시 함수들의 특징을 다시 상기

```python
- 해시 함수 값 충돌의 최소화
  - 고정 크기 값으로 변환하면서 같은 값이 나올 수 있기 때문
- 쉽고 빠른 연산
- 해시 테이블 전체에 해시 값이 균일하게 분포
- 사용할 키의 모든 정보를 이용하여 해싱
  - 최대한 겹치지 않도록
- 해시 테이블 사용 효율이 높을 것
```

#### 1.3 구현
