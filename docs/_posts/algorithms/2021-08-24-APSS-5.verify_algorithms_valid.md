---
title: ASPP - 5. 알고리즘 정당성 증명
author: aimpugn
date: 2021-08-31 00:00:00+0900
use_math: true
categories: [APSS, algorithms]
---

# 알고리즘 정당성 증명

문제가 복잡해지면 알고리즘이 문제를 해결할 수 있는지 어떻게 알 수 있을까? 단위 테스트? 단위 테스트에 대해 책에서는 아래처럼 설명하고 있다.
  
> 단위 테스트는 알고리즘에 문제가 있음을 증명할 수는 있지만, 알고리즘에 문제가 없음을 증명할 수는 없다  

예전엔 이 말이 잘 이해가 안 됐다. 그런데 어려운 문제를 풀려고 이렇게 저렇게 코드를 짜다 보면 '이게 문제를 해결할 수 있을까?'라는 생각이 든다.  
'*내가 짜는 알고리즘에 문제가 없어서 모든 테스트 케이스를 통과할 수 있다는 것*을 어떻게 보장하지?'에 대한 자문에 자답하지 못했다.  
그러니, 내가 짜는 알고리즘이 어디를 목표로 어떻게, 왜 그렇게 가고 있는지도 모른 채 되는대로 풀었던 셈이다.  
풀면 다행이고, 못 풀면 그냥 그 시간 허탕친 셈. 남는 게 없진 않았지만 적었다.  

고등학교 수학처럼 알고리즘을 유형에 따라 그냥 외우면 편할 수도 있고, 사실 선 암기 후 이해도 좋은 학습 방법이라 생각하지만, 머리가 굵어졌는지 이제는 그게 잘 안 된다.  
코드를 짜면서도 '난 왜 이렇게 코드를 짜지?' 같은 생각이 들면 잘 알지도 못하면서 푸는 척 하는 모습에 그냥 더이상 풀고 싶지가 않아진다.  

결국 제대로 풀려면 증명에 대해 이해를 해야 하고, 그 과정에서 *각종 수학적 기법*이 동원되어야 한다고 한다.  
당장 이해가 안 가더라도 정리를 할 필요성을 새삼 느낀다.

## 수학적 귀납법과 반복문 불변식

### 수학적 귀납법

- 증명 대상? *반복적인 구조를 갖는 명제들*
- 알고리즘 정당성 증명 시 가장 유용하게 사용되는 기법

#### 수학적 귀납법의 세 단계

##### 단계 나누기

- 증명하고 싶은 사실을 여러 단계로 나눈다
- 귀납이라 함은 반복되는 사실로 일반화 하는 추리 방법이다
  - 흔히 아는 잘못된 일반화인 *백조는 희다, 왜냐하면 이제까지 관측된 백조는 모두 흰색이었으니까*가 대표적이다
  - 그럼 여기서 *백조는 희다*가 증명하고 싶은 사실이면, *백조 하나하나의 색을 확인하는 것*이 단계 나누기다
- 반복문을 돌든, 재귀적으로 호출하든 어떤 식으로든 답을 찾아가는 단위가 있을 것이다. 즉 알고리즘 내에서 같은 패턴으로 반복되는, 시작과 끝이 있는 한 싸이클이 있을 것이다. 그 한 싸이클을 찾아서 정의하는 것으로 이해가 된다.

##### 첫 단계 증명

- 증명하고 싶은 내용이 성립함을 처음 증명하는 것
- 백조를 하나 찾아서 흰 색임을 보이면 된다

##### 귀납 증명

- 한 백조가 흰 색이었고, 다음 백조가 흰 색임을 보이는 것. 즉 반복적으로 발생함을 보이는 과정
- 어느 순간 검은 백조가 나올 것이고, 그러면 증명은 실패한다.

### 반복문 불변식(loop invariant)

- 반복문의 내용이 한 번 실행될 때마다 중간 결과가 답으로 가는 길 위에 잘 있는지를 명시하는 조건
- 반복문이 마지막에 정답을 계산하기 위해서는 항상 이 식이 변하지 않고 성립되어야 한다

#### 반복문 불변식 증명

1. 반복문 진입시에 불변식 성립함을 보인다
2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다
   - 반복문 내용 시작 시 불변식 성립
   - 반복문 내용 끝날 때 불변식 성립
3. 반복문 종료 시 불변식 성립하면, 정답 구했음을 보인다

```java
/* 불변식은 여기에서 성립 */
while(comeCondition){
  /* 반복문 내용 시작 시 */
            ...
  /* 반복문 내용 끝날 때 */
  /* 불변식은 여기에서도 성립 */
}
```

#### 이진 탐색과 반복문 불변식

```java
/**
  * A[-1]은 음의 무한대, A[n]은 양의 무한대 가정
  * @param A 오름차순으로 정렬되어 있다
  * @param x 찾고자 하는 값
  * @return A[i-1] < x <= A[i]인 i를 반환
  */
public int binarySearch(List<Integer> A, int x) {
    int low = 0, high = A.size();
    /* 1. 반복문 불변식: low < high */
    /* 2. 반복문 불변식: A[low] < x <= A[high] */
    while (low < high) { /* 3. 반복문 종료 시: low >= high */
        int mid = low + (high - low) / 2;
        System.out.printf("mid: %d, (%d - %d) / 2: %d\n", mid, high, low, (high - low) / 2);
        if (A.get(mid) < x) {
            low = mid + 1; /* 책과 다른 부분. 책은 low를 -1로 초기화 */
        } else {
            high = mid;
        }
    }

    return high;
}
```

이진 탐색 내부의 while문은 총 두 개의 반복문 불변식 유지

##### $low \lt high$

- 작은 값은 큰 값보다 항상 작다
- 반복문 종료 시?
  - $low \ge high$가 된다. 이때 $low \lt high$ 반복문 불변식과 조합을 하면,
  - $high \le low \lt high$가 되며, low는 high일 수밖에 없다

##### $A[low] \lt x \le A[high]$

- `x`는 작은 인덱스보다 크고 큰 인덱스보다 작거나 같은 인덱스에 위치한다

> *애초에 불변식이 성립한다고 가정했으니 이것은 당연히 성립*

*`x`라는 값이 리스트 A의 low 인덱스와 high 인덱스 사이에 존재함을 가정했으니 당연히 성립한다*는 게 무슨 말일까?  
만약 `x`에 해당하는 값이 A에 존재하지 않는다면 어떻게 될까? 불변식이 깨진다.  
불변식에 대해 다시 상기해보자면,  

> 불변식은 **반복문이 마지막에 정답을 계산하기 위해서는 항상 이 식이 변하지 않고 성립해야 하는 것**이다

따라서 불변식이 성립하는 한, `x`는 A[log]와 A[high] 사이에 존재한다

#### 반복문 불변식: 결론

지금도 헷갈리지만, 처음보다는 조금 이해가 되는 거 같다.  
*처음에는 왜 혼자 가정하고 그게 성립하다고 하지?*라고 생각했었다.  
근데 이진 탐색 코드는 예제일 뿐이다. 실제로는 **알고리즘을 푸는 사람이 반복문 불변식을 가정해야** 한다.  
즉,

1. 데이터는 재귀적이든 반복문이든 어떤 반복적인 작업에 전달이 되고
2. 알고리즘 조건과 데이터를 통해 귀납적으로 규칙을 발견하여 반복문 불변식을 가정하고
3. 가정된 불변식에 따라 반복문 마지막에 정답을 계산해내는지 확인해야 한다

따라서 정당성 검증에도 마법은 없다. 만약 귀납적인 추론이 잘못되어 잘못된 불변식을 가정하면 어떻게 될까?  
불변식에 맞지 않는 데이터를 확인하게 되고, 불변식과 귀납 추론은 깨지게 되며, 불변식은 더이상 불변식이 아니게 된다.  
  
따라서 불변식을 가정할 수 있다는 것 자체가 애초에 어느 정도 문제를 풀 능력이 된다는 것...으로 이해가 된다.  
결국 귀납 추론을 잘해서 정확한 규칙을 찾고, 규칙에 따라 불변식을 만드는 연습을 해야 할 것 같다.
