---
title: db - MVCC
author: aimpugn
date: 2021-07-25 18:00:00+0900
use_math: true
categories: [db, mvcc]
---

- [RDBMS와 MVCC 아키텍처](#rdbms와-mvcc-아키텍처)
  - [MVCC 아키텍처의 발전](#mvcc-아키텍처의-발전)
    - [RDBMS와 Concurrency Control](#rdbms와-concurrency-control)
    - [MVCC 발전](#mvcc-발전)
      - [1970년](#1970년)
      - [1974년](#1974년)
      - [1976년](#1976년)
      - [1978년](#1978년)
      - [1981년](#1981년)
      - [1984년](#1984년)
      - [1986년](#1986년)
      - [1999년](#1999년)
  - [MVCC의 두 가지 흐름](#mvcc의-두-가지-흐름)
    - [첫번째 흐름](#첫번째-흐름)
      - [`MGA` 예제](#mga-예제)
    - [두번째 흐름](#두번째-흐름)
      - [`Rollback segment` 예제](#rollback-segment-예제)

# RDBMS와 MVCC 아키텍처

## MVCC 아키텍처의 발전

### RDBMS와 Concurrency Control

- 무려 50년 전부터 현 RDBMS와 트랜잭션 등에 대한 연구가 미국에서 이뤄지고 있었다...
- `Multiversion Concurrency control(MVCC)`?
  - Write 세션이 Read 세션을 블로킹하지 않고
  - Read 세션이 Write 세션을 블로킹하지 않고
  - 서로 다른 세션이 동일 데이터에 접근했을 때 각 세션마다 스냅샷 이미지를 보장해주는 매커니즘
  - `Multiversion`이라는 말 그대로, **데이터 변화를 여러 버전으로 관리**하여 동시성 제어를 한다

### MVCC 발전

#### 1970년

- E. F. Codd 박사 $\to$ RDBMS 논문(A relational model of data for large **shared data** banks)
  - 데이터의 독립성
  - 구조적인 간결함
  - SQL 같은 고급 언어를 통한 집합 처리

#### 1974년

- IBM에서 System R프로젝트 시작
- Raymond F. Boyce, Donald D. Chamberlin $\to$ SEQUEL(Structured English Query Language)
- Jim Gray $\to$ ACID, Locking, Recovery 매커니즘 등 트랜잭션 처리 관한 이론 정립
- Michael Stonebraker, 동료 및 제자 $\to$ Ingres(Interactive Graphics and Retrieval System)

#### 1976년

- Bob Miner, Ed Oates, Lally Ellison $\to$ SDL 찹업 후 Oracle DBMS 발표

#### 1978년

- David P. Reed $\to$ READ와 WRITE 경합 최소화 아이디어 제시
  - 어떤 데이터에 여러 차례 수정이 있다고 가정할 때
  - 수정이 가해진 각 시점의 개별 버전을 모두 저장하고(`Multiversion`)
  - 데이터 객체는 이러한 개별 버전들의 연속체로 정의
- `Synchronization`? a mechnism
  - for naming versions to be read and
  - for defining where in the sequence of versions the version resulting from some update should be placed

#### 1981년

- Philip A. Bernstein, Nathan Goodman $\to$ `MVCC`

#### 1984년

- Jim Starkey
  - $\to$ 최초로 Rdb/ELN 제품에 처음으로 MVCC 아키텍처 도입
  - $\to$ 두번째로 Interbase DB에 발전시킨 MVCC 도입하는데, `Multi Generation Architecture(MGA)`라고 한다

#### 1986년

- Bob Miner $\to$ 오라클 version 6에서 `Rollback Segment` 도입

#### 1999년

- Mikheev Vadim B. $\to$ `MGA` 아키텍처 채택하여 PostgreSQL 6.5에 MVCC 아키텍처 도입

## MVCC의 두 가지 흐름

### 첫번째 흐름

- `Multi Generation Architecture, MGA`
  - Tuple 업데이트 시 새로운 값으로 대체하지 않고, 동일한 데이터 페이지 내에서 New Tuple을 새롭게 추가하고 Old Tuple은 유효 범위를 마킹하여 처리

#### `MGA` 예제

- 업데이트 전
  - `XMIN`에 `XID 10` 세팅 & `XMAX` 세팅된 값 없음 = **`XID 10`부터 현재까지 유효** 의미

|         |         |         |
| ------- | ------- | ------- |
| XMIN 10 | XMAX -- | TUPLE 1 |
| XMIN 10 | XMAX -- | TUPLE 2 |
| XMIN 10 | XMAX -- | TUPLE 3 |

- TUPLE 2 업데이트
  - **OLD** TUPLE 2:
    - `XID 30`일 때, 기존 TUPLE 2의 `XMAX`에 `XID 30` 세팅하여 OLD 버전임을 표시
    - $\to$ `XID 10`부터 `XID 30` 범위에서 visible한 값
  - **NEW** TUPLE 2:
    - `XMIN`의 `XID 30`, `XMAX`는 없음
    - $\to$ **`XID 30`부터 현재까지 유효** 의미

|             |             |                 |
| ----------- | ----------- | --------------- |
| XMIN 10     | XMAX --     | TUPLE 1         |
| XMIN 10     | XMAX **30** | **OLD** TUPLE 2 |
| XMIN 10     | XMAX --     | TUPLE 2         |
| XMIN 10     | XMAX --     | TUPLE 3         |
| XMIN **30** | XMAX --     | **NEW** TUPLE 2 |

- 서로 다른 세션끼리 어떻게 Snapshot image를 SELECT?
  - 시점별 XID:
    - T0: `XID 10`
    - T1: `XID 20`
    - T2: `XID 30`
    - T3: `XID 40`

- T1 시점: *SESSION-1* OPEN
  - *SESSION-1* SELECT $\to$ TUPLE 1, TUPLE 2, TUPLE 3 조회

```
PAGE HEADER

          ... FREE SPACE ...

      [TUPLE 3][TUPLE 2][TUPLE 1][PAGE TAIL]
```

- T2 시점:
  - UPDATE TUPLE 2
  - $\to$ 새로운 NEW TUPLE 2가 추가
  - $\to$ OLD TUPLE 2는 XMAX에 유효한 XID 범위값 세팅

```
PAGE HEADER

          ... FREE SPACE ...
                               [NEW TUPLE 2]
  [TUPLE 3][OLD TUPLE 2][TUPLE 1][PAGE TAIL]
```

- T3 시점: *SESSION-3* OPEN
  - *SESSION-1* SELECT $\to$ TUPLE 1, **OLD** TUPLE 2, TUPLE 3 조회
  - *SESSION-3* SELECT $\to$ TUPLE 1, **NEW** TUPLE 2, TUPLE 3 조회

### 두번째 흐름

- 1986년 Bob Miner는 오라클 version 6에서 `Rollback Segment` 도입하여 MVCC 구현
- `Rollback segment` 메커니즘
  - UPDATE 실행
    - $\to$ 기존 데이터 블록 내의 데이터 레코드를 New Version으로 변경
    - $\to$ Old Version을 별도의 저장소인 `Rollback segment`에 보관
  - SELECT 실행
    - $\to$ `SELECT SCN(System Change Number)`과 `데이터 블록의 SCN(System Change Number)`을 비교
    - $\to$ **Consistent Read**가 필요하다고 판단
    - $\to$ 롤백 세그먼트의 Old Version을 읽어서 버퍼캐시에 `CR(Consistence Read) 블록`을 생성
  - SELECT 쿼리의 Snapshot Read를 보장
  - `Ora-1555 snapshot too old`라는 한계점 제외하고는 동시성을 극대화해주는 최고의 방법이었다

#### `Rollback segment` 예제

| data block                       | undo block                 |
| -------------------------------- | -------------------------- |
| ITL(Interested Transaction List) | TX(Transaction) Table Slot |
| Data Row `A`                     |                            |

| data block                       |        | undo block                      |
| -------------------------------- | ------ | ------------------------------- |
| ITL(Interested Transaction List) | ┬XID─> | TX(Transaction) Table Slot ┐UBA |
| Data Row (new Image `B`)         | └UBA─> | Undo Record(Old Image `A`)<┘    |

- `ITL`?
  - [`Interested Transaction List`](https://datacadamia.com/db/oracle/transaction_table)의 약자이며, `transaction table`이라고도 한다
  - [ITL structure in detail](https://avdeo.com/2008/06/16/interested-transaction-list-itl/) 참고
    - Variable header는 위에서 아래로 필요에 따라 증가하고, row는 아래에서 위로 증가
    - ITL은 variable portion of data block header에 위치한다(그러니까 Variable header...?)
    - 이 데이터 블록 헤더의 가변 영역은 트랜잭션에 대한 슬롯들을 갖는다
      - 만약 어떤 row가 lock 된다면? $\to$ 트랜잭션은 lock 된 row의 rowid와 함께 한 슬롯에 lock을 넣는다
      - 달리 말하자면, **트랜잭션이 해당 row에 관심이 있다고 표시**하는 것(그래서 *Interested Transaction List*다)
- `UBA`?
  - `Undo Block Address`
- `Consistence Read`?
  - [[Oracle] 문장수준 읽기 일관성 Consistent Mode, Current Mode 차이 :: 마이자몽](https://myjamong.tistory.com/195) 참고
  - `Consistent`? 일관된, 언행이 일치된, 모순이 없는
  - Consistent Read 위해서, SELECT 시점에 SCN을 비교해서 Undo Segment에 존재하는 해당 Old Versions을 찾아서 버퍼 캐시에 CR 블록 생성
