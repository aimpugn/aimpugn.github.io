---
title: I. A tour of Computer Systems
author: aimpugn
date: 2021-02-02 19:00:00+0900
categories: ["cs", "csapp"]
---

- [A Tour of Computer Systems](#a-tour-of-computer-systems)
  - [개요](#개요)
    - [이 책을 통해 배우는 내용](#이-책을-통해-배우는-내용)
  - [정보는 Bits + Context](#정보는-bits--context)
  - [프로그램은 다른 프로그램에 의해 다른 형식으로 번역된다](#프로그램은-다른-프로그램에-의해-다른-형식으로-번역된다)
  - [컴파일 시스템 동작 방식을 이해하는 것이 좋다](#컴파일-시스템-동작-방식을-이해하는-것이-좋다)
    - [프로그램 성능 최적화](#프로그램-성능-최적화)
    - [link-time 에러 이해](#link-time-에러-이해)
    - [보안상의 구멍 피하기](#보안상의-구멍-피하기)
  - [메모리에 저장된 명령들을 읽고 해석하는 프로세서](#메모리에-저장된-명령들을-읽고-해석하는-프로세서)

# A Tour of Computer Systems

## 개요

- 컴퓨터 시스템 = 하드웨어 + 시스템 소프트웨어 &#8594; 응용 프로그램 실행

### 이 책을 통해 배우는 내용

- **컴퓨터가 숫자를 표현하는 방식**으로 인해 발생하는 수와 관련된 에러들을 피할 수 있는 실전적 스킬
- **현대 프로세서와 메모리 시스셈 디자인을 활용**하는 트릭을 활용하여 C 코드를 어떻게 최적화 할지
- **어떻게 컴파일러가 프로시저 콜을 구현**하고 어떻게 그 지식을 활용하여 네트워크와 인터넷 소프트웨어를 괴롭히는 버퍼 오버플로 취약점으로 인한 보안 허점을 피할 수 있는지
- 일반적인 개발자를 난처하게 만드는 linking 동안 발생하는 다루기 어려운 에러를 어떻게 식별하고 피할 것인지
- 어떻게 Unix shell, dynamic storage allocation package, Web server를 작성하는지
- 멀티 코어가 단일 칩에 통합되면서 중요도가 높아지고 있는 동시성(concurrency)의 전망과 위험
- 이를 hello 프로그램의 생애(lifetime)를 통해 알아본다

```cpp
#include <stdio.h>

int main(){
    printf("hello, world\n");

    return 0;
}
```

## 정보는 Bits + Context

- hello 프로그램은 개발자가 작성한 hello.c라는 텍스트 파일로 저장된 소스 프로그램(또는 소스 파일)에서 그 생이 시작된다
- 소스 프로그램은
  - 비트의 연속이며,
  - 각 비트는 0과 1이라는 값을 가지고,
  - 이는 `bytes`라 불리는 8-bits 뭉치를 구성
- 대부분의 컴퓨터 시스템은 텍스트 문자를 `ASCII 표준`을 사용하여 나타내며, ASCII 표준은 각 문자를 `고유한 byte 크기의 정수 값`으로 나타낸다.

[! ASCII text representation of hello.c](../../assets/images/csapp/ch1/F.1.2.%20The%20ASCII%20text%20representation%20of%20hello.png)

- `hello.c` 프로그램 역시 **일련의 바이트** 파일로 저장
- `hello.c`처럼 오직 ASCII 문자로만 구성된 파일을 `text files`라 하며, 그 외에는 `binary files`라고 한다
- 즉, 시스템에서 모든 정보는 다수의 bits로 나타난다
- 우리가 정보를 보는 **컨텍스트**만이 서로 다른 데이터 오브젝트를 구별한다. 예를 들어, 같은 일련의 bytes라도 서로 다른 컨텍스트에서 정수, 실수, 문자열 또는 기계 명령(machine intruction)을 타나낸다

## 프로그램은 다른 프로그램에 의해 다른 형식으로 번역된다

- 기계가 C 프로그램 읽기 위해서는
  - 반드시 일련의 저레벨 _machine-language(기계어)_ 명령으로 번역되고,
  - 명령들은 _executable object program(executable object files)_ 이라 불리는 형식으로 패키징 되고
  - 바이너리 디스크 파일로 저장된다
- Unix 시스템에서, 소스 파일에서 오브젝트 파일로의 번역은 *compiler driver*에 의해 수행된다
- `$ gcc -o hello hello.c` 실행

  - hello.c 소스 프로그램(텍스트)
  - 전처리(Pre-processor, cpp): 수정된 소스 프로그램(텍스트) 생성
    - `#`으로 시작하는 지시(directives)에 따라 원본 C 프로그램을 수정
    - `#include <stdio.h>` 명령은 전처리로 하여금
      - `stdio.h` 시스템 헤더 파일의 내용을 읽어서
      - 프로그램 텍스트에 직접 삽입하도록 한다
    - `hello.i`: 전처리 결과 새롭게 생성된 C 프로그램
  - 컴파일러(cc1): 어셈블리 프로그램(텍스트) 생성
    - `hello.s`: cc1 컴파일러가 `hello.i`를 번역하여 생성하는 파일. _assembly-language program_ 포함한다.

```assembly
main:
  subq  $8, %rsp
  movl  $.LC0, %edi
  call  puts
  movl  $0, %eax
  addq  $8, %rsp
  ret
```

- Assembler(as): 재배치 가능한 오브젝트 프로그램(바이너리) 생성
  - `hello.o`: `main` 함수에 대한 명령을 인코딩하기 위한 17바이트를 포함하는 바이너리 파일
    - 어셈블러가 `hello.s`를 기계어 명령으로 번역하고,
    - _relocatable object program_ 형식으로 패키징 하여
    - 그 결과를 저장한 파일
- Linker(ld): 실행 가능한 오브젝트 프로그램(바이너리) 생성
  - `printf` 함수는
    - 모든 C 컴파일러가 제공하는 표준 C 라이브러리의 일부로
    - `printf.o`라 불리는 미리 컴파일된 오브젝트 파일에 있으며,
    - 어떤 식으로든 반드시 `hello.o` 프로그램으로 합쳐져야 한다
  - 링커(ld)는 이 합치는 것을 다룬다
  - `hello`:
    - ld의 결과
    - 시스템에 의해 메모리로 로드되고 실행될 준비가 된 실행 가능한 오브젝트 파일(_executable_)

```
hello.c
-> 전처리 -> # 지시에 따라 수정된 hello.i
-> 컴파일 -> 어셈블리어로 번역된 hello.s
-> 에셈블러 -> 재배치 가능 파일 hello.o
-> Linker -> prinf.o와 hello.o 연결
-> 실행 가능한 hello 파일
```

## 컴파일 시스템 동작 방식을 이해하는 것이 좋다

- 정확하고 효율적인 머신 코드 생성 위해 컴파일 시스템에 의존할 수 있지만,
- 개발자가 어떻게 컴파일 시스템이 작동하는지 알아야 할 몇 가지 중요한 이유가 있다

### 프로그램 성능 최적화

- C 프로그램에서 좋은 코딩을 하기 위한 결정을 내리기 위해서는, 기계 수준의 코드와 어떻게 컴파일러가 서로 다른 C 문장을 기계 코드로 번역하는지에 대한 기본적인 이해가 필요하다
- 예를 들어,
  - 연속된 _if-else_ 구문보다 _switch_ 구문이 언제나 더 효과적인가?
  - 함수 모출마다 얼만큼의 오버헤드가 발생하는가?
  - _while_ 반복문이 _for_ 반복문보다 더 효율적인가?
  - 포인터 참조가 배열 인덱스보다 효율적인가?
  - 왜 반복문은 참조로 전달(passed by reference)되는 인자 대신 지역 변수로 통합(sum into)했을 때 훨씬 빠른가? (TODO 지역 변수로 통합이란?)
  - 산술 표현식에서 단순히 괄호를 재배열할 때 어떻게 함수 속도가 더 빨리지는가?

### link-time 에러 이해

- 경험상, 대부분의 복잡한(perplexing) 개발 에러는 linker 작업과 관련이 있다
- 예를 들어,
  - 링커가 참조를 확인할 수 없다(cannot resolve a reference)는 보고는 무슨 의미인가?
  - 정적 변수와 전역 변수의 차이점은 무엇인가?
  - 서로 다른 C 파일에서 같은 이름으로 두 전역 변수를 선언하면 어떻게 되는가?
  - 정적 라이브러리와 동적 라이브러리의 차이는 무엇인가?
  - cli(command line)에서 어떤 순서로 라이브러리를 나열하는 것이 무슨 상관일까?
  - 무엇보다 가장 두려운 것은, 왜 링커 관련된 에러는 런타임 때까지 나타나지 않을까?

### 보안상의 구멍 피하기

- 수년 동안 _buffer overflow_ 취약점은 네트워크와 인터넷 서버에서 보안 허점의 많은 부분을 차지했다
- 이러한 취약점은 신뢰할 수 없는 출처로부터 수신하는 데이터의 양(quantity)과 형태(form)를 신중하게 제한할 필요성을 극히 적은 개발자들만 이해했기 때문에 존재한다
- 안전안 프로그래밍을 배우는 첫번째 단계는 **데이터와 제어 정보가 프로그램 스택에 저장되는 방식의 결과**를 이해하는 것

## 메모리에 저장된 명령들을 읽고 해석하는 프로세서
