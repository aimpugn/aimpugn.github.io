---
title: 3.6. 실수 자료형의 이해
author: aimpugn
date: 2020-10-14 11:27:00 +0900
categories: [알고리즘 문제해결전략]
tags: [algorithms]
math: true
use_math: true
---
## [실수 연산의 어려움](#3.6.1)
```javascript 1.8
function countObvious(n) {
    let same = 0;
    for(let x = 1; x <= n; ++x) {
        let y = 1.0 / x;
         if(y * x == 1.0) {
             ++same;
         }
    }

    return same;
}
```
1. $$ \frac {1} {x} \times x $$인 x의 개수를 세는 함수
2. countObvious(50)? 49
    - ~~버그인가?~~
    - ~~CPU의 문제인가?~~
    - 실수 표현 방식의 문제 O 
## [실술와 근사값](#3.6.2)

### [정수형](#3.6.2.1)
컴퓨터가 모두 정확하게 표현 가능

### [실수형](#3.6.2.2)
컴퓨터가 모두 정확하게 표현 불가능

#### [문제점](#3.6.2.2.1)
**소수점 이하 자릿수 정확도**의 문제
1. 순환/비순환 무한소수의 경우 소수점 이하 자릿수가 무한함
2. 모든 자릿수를 정확하게 표현할 수 없으므로 적절히 비슷한 근사값을 사용

#### [영향 요소](#3.6.2.2.2)
1. 어떤 순서로 계산하는지
2. 컴파일러 최적화를 켰는지
    > x86 아키텍처에서 C++ 컴파일러 최적화 설정에 따라 64비트 실수형 변수를 내부적으로 80비트 실수 레지스터에 담은 채 그대로 사용할 수 있다 
3. 중간에 로그 메시지 출력하는지
    > 로깅 함수 호출 시 80비트 레지스터에 담긴 값을 스택에 잠시 저장하면서 이 값들이 64비트로 변경되고, 이때 잘려나간 부분에 있던 값들이 답에 영향

## [IEEE 754 표준](#3.6.3)
가장 많은 컴퓨터/컴파일러들에서 사용하는 실수 표기 방식

### [내용](#3.6.3.1)
1. 매우 방대한 규모의 표준
2. 무한대, 비정규 수(subnormal number), NaN(Not a Number) 등의 특수한 ㄱ밧 존재
3. 오버플로와 언더플로 처리
4. 반올림에 관한 규정

### [특징](#3.6.3.2)

#### [이진수로 실수 표기](#3.6.3.2.1)
1. $$ \frac {1} {2^i} $$: 소수점 밑 i번째 자리의 크기
2. 1011.101
    - 1011: $$ 2^3 + 2^1 + 2^0 = 8 + 2 + 1 = 11 $$
    - .101: $$ \frac{1}{2} + \frac{1}{2^1} = \frac{1}{2} + \frac{1}{8} = 0.625 $$

#### [부동 소수점(floating-point) 표기법](#3.6.3.2.2)

##### [문제점](#3.6.3.2.2.1)
**정수부/소수부에 사용 가능한 비트들을 어떻게 배분**할 것인지의 문제
1. **정수부**에 많은 비트 사용 $$ \rightarrow $$ 소수부 정확도 떨어짐
2. **소수부**에 많은 비트 사용 $$ \rightarrow $$ 큰 수 표현 불가

##### [해결](#3.6.3.2.2.2)
위 문제 해결 위해 소수점을 옮길 수 있도록 함

###### [방식](#3.6.3.2.2.2.1)
1. 소수점을 적절히 옮겨서 소수점 위에 한 자리만 남도록 한다
2. 최상위 비트에서부터 표현할 수 있는 만큼 표시한다
3. 나머지는 반올림한다
4. 이진법으로 표현되므로, 소수점 앞의 숫자는 1만 가능하므로, IEEE 754에서는 소수점 앞의 1을 제외
 
###### [예제](#3.6.3.2.2.2.1)
1. $$ 11.625 \rightarrow 2진법 \rightarrow 1001.101 \rightarrow 1.011101 $$
2. 1.011101 맨 앞에서부터 표현할 수 있는 만큼 표시

##### [실수 변수 구조](#3.6.3.2.2.3)
###### [저장 정보](#3.6.3.2.2.3.1)
1. $$ 6.62607004 \times 10^{-34} $$
2. 부호 비트: 양수/음수 여부
3. 지수(exponent): $$ 10^{-34} $$
4. 가수(mantissa): $$ 6.62607004 $$

###### [예제](#3.6.3.2.2.3.2)
1. 263.3
    - 263: $$ 1 0000 0111 $$
    - 0.3: $$ 0.0100 1100 1100 1100\dddot $$
2. $$ 100000111 . 01001100110011\dddot $$
    1. $$ 1 . 00000111 01001100110011\dddot $$: 소수점을 앞을 8회 이동
    2. 부호비트: 0
    3. 지수 비트:
        - **bias**(32비트의 경우 127 = 0111 1111) + 지수(소수점 이동 횟수) = 127 + 8 = 135 = 1000 0111
        - bias를 더하는 이유는?
            - 지수는 **부호 있는 값**이며, 큰 값과 작은 값 모두 표현 가능
            - 하지만 부호 있는 값에서 [**2의 보수**](https://ko.wikipedia.org/wiki/2%EC%9D%98_%EB%B3%B4%EC%88%98)는 비교를 어렵게 함 $$ \Rightarrow $$ 지수를 **부호 없는 수**로 저장하여 비교하기 쉽게 만든다 
            - 즉, 음의 지수 값을 양수로 표현하기 위해 bias를 더한다
    4. 가수 비트: $$ 00000111 01001100110011\dddot $$ $$
3. 최종적으로 비트는 다음과 같다
```
부호  지수          가수 비트
0     1000 0111    00000111 01001100110011
```
